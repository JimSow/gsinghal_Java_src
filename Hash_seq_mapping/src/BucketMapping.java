// BucketMapping.java

import java.util.*;

public class BucketMapping {
	static final double LOAD = 0.5;     // default load factor
	static final MappingRecord DELETED = new MappingRecord("","");     // sentinels for deleted

	MappingRecord[]table;
	int probe = 0;


	BucketMapping(int Capacity){

		int size = (int)(Capacity/LOAD); // desired hash table size

		int length; 					// length of hash table based on power of 2
		double log2x = Math.log(size)/Math.log(2);

		if (log2x%1 == 0){
			length = (int)(Math.pow(2,log2x));
		}
		else {
			length = (int)(Math.pow(2,(int)(log2x + 1)));
		}


		this.table = new MappingRecord[(int)(length)];

	}


	public void put(String key, Object data) throws Exception {
		int m = table.length;
		int hC = hash(hashCode(key));
		int step = stepHash(hashCode(key));

		boolean inserted = false;

		for(int i = 0 ; i < m; i++ ){

			int j = (hC + i*step)%m;
			//System.out.println("j = "+j);
			if (table[j] == null){ // when the slot is empty, make a new MappingRecord at that slot
				table[j] = new MappingRecord(key, data);
				inserted = true;
				break;
			}
			else if(table[j]== DELETED){ // when the slot is DELETED, it is considered empty, so make a new MappingRecord at that slot
				table[j] = new MappingRecord(key, data); 
				inserted = true;
				break;
			}

			else if (table[j].K.equals(key)){ //when the slot is not empty and contains the same key, add to the bucket
				add(table[j],data); 
				inserted = true;
				break;

			}
		} // move on to the next slot in the probe sequence
		if(!inserted){
			throw new Exception("Table is full");
		}
	}


	public void remove(String key){
		int hC = hash(hashCode(key));
		int step = stepHash(hashCode(key));
		int m = table.length;

		for(int i = 0 ; i < m; i++ ){
			int j = (hC + i*step)%m;
			//System.out.println("j = "+j);
			if ((table[j] != null) && (table[j].K.equals(key))){ 
				table[j] = DELETED;
				break;

			}
		}
	}

	public boolean contains(String key){
		int hC = hash(hashCode(key));
		int step = stepHash(hashCode(key));
		int m = table.length;

		boolean ans = false;

		for(int i = 0 ; i < m; i++ ){
			int j = Math.abs((hC + i*step)%m);
			if ((table[j] != null) && (table[j].K.equals(key))){
				ans = true;
				return ans;
			}
		}

		return ans;
	}

	public Iterator<Object> get(String key){

		int hC = hash(hashCode(key));
		int step = stepHash(hashCode(key));
		int m = table.length;
		probe++; // one probe is always made

		for(int i = 0 ; i < m; i++ ){
			int j = (hC + i*step)%m;

			if (table[j]!=null){
				probe++;
				if (table[j].K.equals(key)){ 
					//					probe = probe+pr; 
					return table[j].iter();
				}	
			}
			else return null;


		}
		return null;
	}


	public int size(){
		int a = 0;
		for(int i=0 ; i<table.length; i++){
			if((table[i]!= null)){//&&(table[i]!=DELETED)){ // when computing load factor, i count the slots which contain DELETED 
				a++;
			}
		}
		return a;
	}


	//  FILL IN THE GUTS OF THIS CLASS HERE

	// Converts a string into an integer to use for the hash functions.
	// This function is based upon a linear-congruential pesudorandom number
	// generator, in which successive values r_i are  generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment used to
	// ensure we don't just compute successive powers of A mod M.
	//
	// The above generator is modified to add thee ith character of the
	// string and its offset, to alter the pseudorandom sequence.

	int hashCode(String s){
		int A = 1952786893;
		int B = 367253;
		int v = B;

		for (int j = 0; j < s.length(); j++){
			char c = s.charAt(j);
			v = A * (v + (int)c + j) + B;
		}
		if (v < 0) v = -v;  //return a positive integer
		return v;
	}

	// Primary hash function using the multiplication method
	//   Computes hashKey*a - floor(k*a) and keeps most two significant digits
	//   of the resulting fraction to return 
	//
	// The below assumes that the hash table is called table

	int hash(int hashKey){
		double a = (Math.sqrt(5.0)-1)/2;
		double frac = (hashKey * a) - (int)(hashKey * a);
		int hashValue = (int) (table.length * frac);
		return hashValue;                                
	}

	// 
	// Secondary hash function which is guaranteed to be odd.  To esnure that all
	// table entries are visited, this requrires that tableSize is a power of 2. 

	int stepHash(int hashKey){
		int step = (hashKey % (table.length/2 - 1));
		return 2*step + 1;
	}

	void add(MappingRecord bucket, Object data){
		bucket.add(data);
	}

}
